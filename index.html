<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Document Scanner ‚Äî Auto-rotate + Learn</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg,#667eea,#764ba2); min-height: 100vh; padding: 20px; color: #0f172a; }
    .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 16px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.08); }
    .header { background: linear-gradient(135deg,#4f46e5,#7c3aed); color: white; padding: 28px; text-align: center; }
    .header h1 { font-size: 2rem; margin-bottom: 6px; }
    .header p { opacity: .9; margin-top: 4px; font-size: 0.95rem; }
    .upload-section { padding: 22px; text-align: center; }
    .upload-area { border: 3px dashed #4f46e5; border-radius: 12px; padding: 42px; margin-bottom: 18px; transition: all .18s ease; background: linear-gradient(135deg,#f8fafc,#e2e8f0); cursor: pointer; }
    .upload-area:hover { border-color: #7c3aed; transform: translateY(-2px); }
    .upload-area.dragover { border-color:#7c3aed; background: linear-gradient(135deg,#ede9fe,#c4b5fd); }
    .upload-icon { font-size: 48px; color: #4f46e5; margin-bottom: 12px; display:block; }
    .upload-text { font-size: 1.15rem; font-weight: 700; color: #0f172a; margin-bottom: 6px; }
    .upload-subtext { color: #64748b; }
    #imageInput { display: none; }
    .controls { margin-top: 12px; display:flex; align-items:center; justify-content:center; gap:12px; flex-wrap:wrap; }
    .btn { background: linear-gradient(135deg,#4f46e5,#7c3aed); color: #fff; border: none; padding: 10px 14px; border-radius: 8px; font-weight:700; cursor: pointer; box-shadow: 0 6px 18px rgba(79,70,229,0.18); }
    .btn:disabled { opacity: .45; cursor: not-allowed; transform: none; box-shadow: none; }
    .tiny { padding: 8px 10px; font-weight:600; border-radius: 8px; }
    .progress-container { margin: 18px 0; display:none; }
    .progress-bar { background: #e6eefb; border-radius: 8px; height: 10px; overflow: hidden; }
    .progress-fill { background: linear-gradient(90deg,#4f46e5,#7c3aed); height: 100%; width:0%; transition: width .2s ease; }
    .progress-text { margin-top:8px; color:#64748b; font-weight:600; font-size:0.95rem; }
    .pages-grid { display: grid; grid-template-columns: repeat(auto-fill,minmax(220px,1fr)); gap: 18px; margin-top: 20px; padding: 18px; }
    .page-item { border: 2px solid #e6eefb; border-radius: 12px; padding: 12px; background: #fff; display:flex; flex-direction:column; align-items:center; gap:8px; }
    .page-preview { width:100%; max-width:180px; height:auto; border-radius:6px; background:#fafafa; box-shadow: 0 6px 18px rgba(9,10,11,0.03); }
    .page-info { font-size: 0.95rem; color:#475569; font-weight:700; }
    .meta { font-size: 0.8rem; color:#64748b; }
    .rotation-info { font-size: 0.85rem; color:#7c3aed; font-weight:700; }
    .rotate-controls { display:flex; gap:8px; margin-top:6px; flex-wrap:wrap; }
    .rotate-controls button { padding:8px 10px; border-radius:8px; border:1px solid #eef2ff; background:#fff; cursor:pointer; font-weight:700; }
    .status { margin: 14px auto; padding: 12px; border-radius: 10px; display:none; max-width: 880px; text-align: center; font-weight:700; }
    .status.processing { display:block; background: linear-gradient(135deg,#fffbeb,#fef3c7); color:#92400e; border:1px solid #f59e0b; }
    .status.success { display:block; background: linear-gradient(135deg,#dcfce7,#bbf7d0); color:#166534; border:1px solid #22c55e; }
    .status.error { display:block; background: linear-gradient(135deg,#fef2f2,#fecaca); color:#dc2626; border:1px solid #ef4444; }
    .learned-badge { font-size: 0.72rem; color: #fff; background: #10b981; padding: 3px 6px; border-radius: 6px; }
    .small-note { color:#64748b; font-size:0.9rem; }
    @media (max-width: 760px) { .pages-grid { grid-template-columns: repeat(auto-fill,minmax(150px,1fr)); gap:12px; } .upload-area { padding: 26px; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìÑ Document Scanner ‚Äî Auto-rotate + Learn</h1>
      <p>Auto-detect orientation; fix mistakes and the app learns locally for next time.</p>
    </div>

    <div class="upload-section">
      <div class="upload-area" id="uploadArea">
        <div class="upload-icon">üì∑</div>
        <div class="upload-text">Click to upload or drag & drop images</div>
        <div class="upload-subtext">Supports JPG/PNG. Any orientation will be auto-corrected ‚Äî you can fix mistakes below.</div>
      </div>

      <input id="imageInput" type="file" accept="image/*" multiple />

      <div class="controls" style="margin-top:12px;">
        <button id="processBtn" class="btn tiny" disabled>üîÑ Process Images</button>
        <button id="downloadBtn" class="btn tiny">üì• Download PDF</button>
        <button id="clearBtn" class="btn tiny">üóëÔ∏è Clear All</button>

        <label style="display:inline-flex;align-items:center;gap:8px;margin-left:8px;">
          <input id="autoLearnToggle" type="checkbox" checked />
          <span class="small-note">Auto-learn</span>
        </label>

        <div id="modelInfo" class="small-note" style="margin-left:10px;"></div>

        <button id="exportBtn" class="btn tiny" title="Export model">‚¨ÜÔ∏è Export</button>
        <button id="importBtn" class="btn tiny" title="Import model">‚¨áÔ∏è Import</button>
        <button id="resetModelBtn" class="btn tiny" title="Reset model">‚ôªÔ∏è Reset Model</button>
      </div>

      <div class="progress-container" id="progressContainer">
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        <div class="progress-text" id="progressText">Processing images...</div>
      </div>

      <div id="status" class="status"></div>

      <div class="pages-grid" id="pagesGrid"></div>
    </div>
  </div>

<script>
/* ========= State & UI refs ========= */
let uploadedImages = []; // { file, dataUrl }
let processedPages = []; // index aligned: { canvas, rotation, originalDataUrl, features, choseBy }
const STORAGE_KEY = 'orientation_training_v1';

const imageInput = document.getElementById('imageInput');
const uploadArea = document.getElementById('uploadArea');
const pagesGrid = document.getElementById('pagesGrid');
const processBtn = document.getElementById('processBtn');
const downloadBtn = document.getElementById('downloadBtn');
const clearBtn = document.getElementById('clearBtn');
const progressContainer = document.getElementById('progressContainer');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const statusEl = document.getElementById('status');
const autoLearnToggle = document.getElementById('autoLearnToggle');
const modelInfo = document.getElementById('modelInfo');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const resetModelBtn = document.getElementById('resetModelBtn');

/* ========= Drag & input ========= */
uploadArea.addEventListener('click', () => imageInput.click());
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragover'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
uploadArea.addEventListener('drop', e => { e.preventDefault(); uploadArea.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
imageInput.addEventListener('change', e => handleFiles(e.target.files));

/* ========= File handling ========= */
function handleFiles(files) {
  const valid = Array.from(files).filter(f => f.type && f.type.startsWith('image/'));
  if (!valid.length) { showStatus('Please select valid image files.', 'error'); return; }
  const readers = valid.map(f => new Promise(res => {
    const r = new FileReader();
    r.onload = () => res({ file: f, dataUrl: r.result });
    r.readAsDataURL(f);
  }));
  Promise.all(readers).then(results => {
    uploadedImages = uploadedImages.concat(results);
    processBtn.disabled = false;
    showStatus(`${uploadedImages.length} images ready for processing`, 'success');
    renderPagesGrid();
  });
}

/* ========= Render pages grid (initial previews) ========= */
function renderPagesGrid() {
  pagesGrid.innerHTML = '';
  for (let i = 0; i < uploadedImages.length; i++) {
    const entry = uploadedImages[i];
    const div = document.createElement('div');
    div.className = 'page-item';
    div.dataset.index = i;
    div.innerHTML = `
      <img id="preview-${i}" src="${entry.dataUrl}" class="page-preview" alt="Page ${i+1}" />
      <div class="page-info">Page ${i+1} <span id="model-${i}" class="meta"></span></div>
      <div id="rotation-${i}" class="rotation-info">Not processed</div>
      <div class="rotate-controls">
        <button data-action="ccw" data-index="${i}" disabled title="Rotate 90¬∞ CCW">‚ü≤</button>
        <button data-action="reset" data-index="${i}" disabled title="Reset">‚Ü∫</button>
        <button data-action="cw" data-index="${i}" disabled title="Rotate 90¬∞ CW">‚ü≥</button>
        <button data-action="del" data-index="${i}" title="Delete">üóë</button>
      </div>
    `;
    pagesGrid.appendChild(div);
  }
  pagesGrid.querySelectorAll('button[data-action]').forEach(b => {
    b.onclick = (e) => {
      const action = b.getAttribute('data-action');
      const idx = Number(b.getAttribute('data-index'));
      if (action === 'ccw') manualRotate(idx, -90);
      if (action === 'cw') manualRotate(idx, 90);
      if (action === 'reset') resetPageRotation(idx);
      if (action === 'del') deletePage(idx);
    };
  });
}

/* ========= Status helper ========= */
function showStatus(msg, type) {
  if (!type) { statusEl.style.display = 'none'; return; }
  statusEl.style.display = 'block';
  statusEl.textContent = msg;
  statusEl.className = 'status ' + (type === 'processing' ? 'processing' : (type === 'success' ? 'success' : 'error'));
}

/* ========= Feature extraction utilities ========= */
function getGrayDataForCanvas(canvas) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const image = ctx.getImageData(0,0,w,h).data;
  const gray = new Uint8Array(w*h);
  for (let i=0, j=0; i<image.length; i+=4, j++) {
    const g = Math.round(0.299*image[i] + 0.587*image[i+1] + 0.114*image[i+2]);
    const enhanced = g < 128 ? Math.max(0, g-30) : Math.min(255, g+30);
    gray[j] = enhanced;
  }
  return { gray, width: w, height: h };
}

function detectTextLinesFromGray(gray, width, height) {
  let horizontalLines = 0, verticalLines = 0;
  for (let y=Math.floor(height*0.1); y<height*0.9; y+=3) {
    let black = 0, transitions = 0;
    let prev = gray[y*width + Math.floor(width*0.1)];
    for (let x=Math.floor(width*0.1); x<width*0.9; x++) {
      const p = gray[y*width + x];
      if (p < 128) black++;
      if (Math.abs(p - prev) > 50) transitions++;
      prev = p;
    }
    if (black > width*0.05 && black < width*0.5 && transitions > 3) horizontalLines++;
  }
  for (let x=Math.floor(width*0.1); x<width*0.9; x+=3) {
    let black = 0, transitions = 0;
    let prev = gray[Math.floor(height*0.1)*width + x];
    for (let y=Math.floor(height*0.1); y<height*0.9; y++) {
      const p = gray[y*width + x];
      if (p < 128) black++;
      if (Math.abs(p - prev) > 50) transitions++;
      prev = p;
    }
    if (black > height*0.05 && black < height*0.5 && transitions > 3) verticalLines++;
  }
  const ratio = horizontalLines / Math.max(verticalLines, 1);
  return Math.min(ratio * 100, 300);
}

function calculateAspectScoreWH(width, height) {
  const ar = height / width;
  if (ar > 1.2) return 100;
  if (ar > 0.8) return 50;
  return 10;
}

function calculateEdgeDirectionFromGray(gray, width, height) {
  let horiz = 0, vert = 0;
  for (let y=1; y<height-1; y+=2) {
    for (let x=1; x<width-1; x+=2) {
      const topRow = gray[(y-1)*width + x-1] + 2*gray[(y-1)*width + x] + gray[(y-1)*width + x+1];
      const bottomRow = gray[(y+1)*width + x-1] + 2*gray[(y+1)*width + x] + gray[(y+1)*width + x+1];
      const horizontalEdge = Math.abs(topRow - bottomRow);
      const leftCol = gray[(y-1)*width + x-1] + 2*gray[y*width + x-1] + gray[(y+1)*width + x-1];
      const rightCol = gray[(y-1)*width + x+1] + 2*gray[y*width + x+1] + gray[(y+1)*width + x+1];
      const verticalEdge = Math.abs(leftCol - rightCol);
      horiz += horizontalEdge;
      vert += verticalEdge;
    }
  }
  const ratio = horiz / Math.max(vert, 1);
  return Math.min(ratio * 50, 200);
}

function calculateWhiteSpaceFromGray(gray, width, height) {
  let horizontalWhiteSpaceLines = 0;
  for (let y=0; y<height; y+=5) {
    let white = 0;
    for (let x=Math.floor(width*0.1); x<width*0.9; x++) {
      if (gray[y*width + x] > 200) white++;
    }
    if (white > (width * 0.8 * 0.7)) horizontalWhiteSpaceLines++;
  }
  return Math.min(horizontalWhiteSpaceLines * 2, 100);
}

function computeFeaturesFromCanvas(canvas) {
  const max = 800;
  let small = canvas;
  if (Math.max(canvas.width, canvas.height) > max) {
    small = document.createElement('canvas');
    const scale = max / Math.max(canvas.width, canvas.height);
    small.width = Math.round(canvas.width * scale);
    small.height = Math.round(canvas.height * scale);
    small.getContext('2d').drawImage(canvas, 0, 0, small.width, small.height);
  }
  const { gray, width, height } = getGrayDataForCanvas(small);
  const textLineScore = detectTextLinesFromGray(gray, width, height);
  const aspectScore = calculateAspectScoreWH(width, height);
  const edgeScore = calculateEdgeDirectionFromGray(gray, width, height);
  const whiteSpaceScore = calculateWhiteSpaceFromGray(gray, width, height);
  return [
    textLineScore / 300,
    aspectScore / 100,
    edgeScore / 200,
    whiteSpaceScore / 100,
    width / 1000,
    height / 1000
  ];
}

/* ========= Enhanced KNN + bucket dedupe + import/export ========= */
const BUCKET_PRECISION = 2;
const K = 7;
const KNN_CONF_THRESH = 0.7;
const MAX_EXAMPLES = 600;
const PRUNE_TO = 500;

function featuresKey(features, precision = BUCKET_PRECISION) {
  return features.map(f => Number(f.toFixed(precision))).join(',');
}

function loadTrainingData() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return parsed.map(e => {
      if (e.count == null) e.count = 1;
      if (e.ts == null) e.ts = Date.now();
      return e;
    });
  } catch (e) {
    console.warn('Failed load model', e);
    return [];
  }
}

function saveTrainingData(arr) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
    updateModelInfo();
  } catch (e) {
    console.warn('Failed save model', e);
  }
}

function updateModelInfo() {
  const data = loadTrainingData();
  const total = data.reduce((s, e) => s + (e.count || 1), 0);
  const uniq = data.length;
  modelInfo.textContent = `Model: ${uniq} buckets (${total} examples)`;
}
updateModelInfo();

function saveTrainingExample(features, rotation) {
  if (!autoLearnToggle.checked) {
    showStatus('Auto-learn is off ‚Äî correction not saved', 'success');
    setTimeout(()=> showStatus('', null), 800);
    return;
  }
  const key = featuresKey(features);
  const data = loadTrainingData();
  // find exact bucket with same features & rotation
  let foundIndex = -1;
  for (let i=0;i<data.length;i++) {
    if (featuresKey(data[i].features) === key && data[i].rotation === rotation) {
      foundIndex = i;
      break;
    }
  }
  if (foundIndex >= 0) {
    data[foundIndex].count = (data[foundIndex].count || 1) + 1;
    data[foundIndex].ts = Date.now();
  } else {
    // else store as new bucket (rotate-label appended to key if needed)
    data.push({ features: features.slice(), rotation, count: 1, ts: Date.now() });
  }

  // prune by total example counts if too large
  let totalCount = data.reduce((s,e)=> s + (e.count||1), 0);
  if (totalCount > MAX_EXAMPLES) {
    // sort by count desc, ts desc
    data.sort((a,b)=> (b.count||1) - (a.count||1) || b.ts - a.ts);
    const kept = [];
    let acc = 0;
    for (const e of data) {
      if (acc >= PRUNE_TO) break;
      kept.push(e);
      acc += (e.count || 1);
    }
    saveTrainingData(kept);
  } else {
    saveTrainingData(data);
  }

  showStatus('Saved correction ‚Äî model updated locally', 'success');
  setTimeout(()=> showStatus('', null), 800);
}

function predictWeightedKNN(features, k = K) {
  const data = loadTrainingData();
  if (!data.length) return null;
  const eps = 1e-6;
  const dists = data.map(d => {
    let s = 0;
    for (let i=0;i<features.length;i++) {
      const diff = features[i] - (d.features[i] || 0);
      s += diff * diff;
    }
    return { rotation: d.rotation, d: Math.sqrt(s), count: d.count || 1, ts: d.ts || 0 };
  });
  dists.sort((a,b) => a.d - b.d);
  const chosen = dists.slice(0, Math.min(k, dists.length));
  const votes = {};
  let totalWeight = 0;
  for (const n of chosen) {
    const w = (n.count || 1) / (n.d + eps);
    votes[n.rotation] = (votes[n.rotation] || 0) + w;
    totalWeight += w;
  }
  const entries = Object.entries(votes).sort((a,b) => b[1] - a[1]);
  if (!entries.length) return null;
  const best = entries[0];
  return { rotation: Number(best[0]), confidence: best[1] / totalWeight };
}

function importModelFromArray(arr) {
  const map = {};
  for (const ex of arr) {
    if (!ex.features || ex.rotation == null) continue;
    const key = featuresKey(ex.features);
    const mapKey = key + '|' + ex.rotation;
    if (!map[mapKey]) map[mapKey] = { features: ex.features.slice(), rotation: ex.rotation, count: 0, ts: Date.now() };
    map[mapKey].count += ex.count || 1;
  }
  const out = Object.values(map);
  out.sort((a,b) => (b.count||1) - (a.count||1));
  if (out.length > MAX_EXAMPLES) out.splice(PRUNE_TO);
  saveTrainingData(out);
  updateModelInfo();
  showStatus('Model imported and deduped', 'success');
  setTimeout(()=> showStatus('', null), 900);
}

function exportModelToFile() {
  const data = loadTrainingData();
  const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'orientation_model.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

/* hook up import/export buttons */
exportBtn.addEventListener('click', exportModelToFile);
importBtn.addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json';
  input.onchange = async (e) => {
    const f = e.target.files[0];
    if (!f) return;
    try {
      const txt = await f.text();
      const parsed = JSON.parse(txt);
      importModelFromArray(parsed);
    } catch (err) {
      alert('Invalid model file');
    }
  };
  input.click();
});
resetModelBtn.addEventListener('click', () => {
  if (!confirm('Reset learned model (clears local storage)?')) return;
  localStorage.removeItem(STORAGE_KEY);
  updateModelInfo();
  showStatus('Model reset', 'success');
  setTimeout(()=> showStatus('', null), 900);
});

/* ========= Image rotation helpers & heuristics ========= */
function drawRotatedCanvasFromImage(img, degrees) {
  const deg = ((degrees % 360) + 360) % 360;
  const c = document.createElement('canvas');
  const ctx = c.getContext('2d');
  if (deg === 0) { c.width = img.naturalWidth; c.height = img.naturalHeight; ctx.drawImage(img, 0, 0); return c; }
  if (deg === 180) {
    c.width = img.naturalWidth; c.height = img.naturalHeight;
    ctx.translate(c.width/2, c.height/2);
    ctx.rotate(deg * Math.PI / 180);
    ctx.drawImage(img, -img.naturalWidth/2, -img.naturalHeight/2);
    return c;
  }
  // 90 or 270
  c.width = img.naturalHeight; c.height = img.naturalWidth;
  ctx.translate(c.width/2, c.height/2);
  ctx.rotate(deg * Math.PI / 180);
  ctx.drawImage(img, -img.naturalWidth/2, -img.naturalHeight/2);
  return c;
}

function rotateCanvas(srcCanvas, degrees) {
  const deg = ((degrees % 360) + 360) % 360;
  if (deg === 0) return srcCanvas;
  const dst = document.createElement('canvas');
  const ctx = dst.getContext('2d');
  if (deg === 180) {
    dst.width = srcCanvas.width; dst.height = srcCanvas.height;
    ctx.translate(dst.width/2, dst.height/2); ctx.rotate(deg * Math.PI / 180);
    ctx.drawImage(srcCanvas, -srcCanvas.width/2, -srcCanvas.height/2);
    return dst;
  }
  dst.width = srcCanvas.height; dst.height = srcCanvas.width;
  ctx.translate(dst.width/2, dst.height/2); ctx.rotate(deg * Math.PI / 180);
  ctx.drawImage(srcCanvas, -srcCanvas.width/2, -srcCanvas.height/2);
  return dst;
}

function analyzeCombinedScore(canvas) {
  const features = computeFeaturesFromCanvas(canvas);
  return (features[0]*0.4) + (features[1]*0.2) + (features[2]*0.3) + (features[3]*0.1);
}

/* ========= Core detection: first try KNN, else heuristics ========= */
async function detectAndCorrectOrientation(dataUrl) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      // draw original canvas to compute stable features
      const orig = document.createElement('canvas');
      orig.width = img.naturalWidth; orig.height = img.naturalHeight;
      orig.getContext('2d').drawImage(img, 0, 0);
      const originalFeatures = computeFeaturesFromCanvas(orig);

      // try KNN
      const knn = predictWeightedKNN(originalFeatures, K);
      if (knn && knn.confidence >= KNN_CONF_THRESH) {
        const finalCanvas = drawRotatedCanvasFromImage(img, knn.rotation);
        resolve({ canvas: finalCanvas, rotation: knn.rotation, features: originalFeatures, choseBy: 'knn', originalDataUrl: dataUrl });
        return;
      }

      // fallback to heuristics (test 0/90/180/270)
      const rotations = [0,90,180,270];
      let best = { rot: 0, score: -Infinity };
      for (const r of rotations) {
        const testCanvas = drawRotatedCanvasFromImage(img, r);
        const s = analyzeCombinedScore(testCanvas);
        if (s > best.score) best = { rot: r, score: s };
      }
      const final = drawRotatedCanvasFromImage(img, best.rot);
      resolve({ canvas: final, rotation: best.rot, features: originalFeatures, choseBy: 'heuristic', originalDataUrl: dataUrl });
    };
    img.src = dataUrl;
  });
}

/* ========= Processing flow ========= */
processBtn.addEventListener('click', processImages);
downloadBtn.addEventListener('click', generatePDF);
clearBtn.addEventListener('click', clearAll);

async function processImages() {
  if (!uploadedImages.length) return;
  processBtn.disabled = true;
  progressContainer.style.display = 'block';
  showStatus('Processing images...', 'processing');
  processedPages = [];
  for (let i=0;i<uploadedImages.length;i++) {
    progressFill.style.width = `${Math.round((i / uploadedImages.length) * 100)}%`;
    progressText.textContent = `Processing image ${i+1} of ${uploadedImages.length}...`;
    try {
      const result = await detectAndCorrectOrientation(uploadedImages[i].dataUrl);
      result.originalDataUrl = uploadedImages[i].dataUrl;
      processedPages[i] = result;
      renderProcessedPreview(i);
    } catch (err) {
      console.error('Error processing', err);
      showStatus(`Error processing image ${i+1}`, 'error');
    }
  }
  progressFill.style.width = '100%';
  progressText.textContent = 'Processing complete!';
  setTimeout(() => { progressContainer.style.display = 'none'; showStatus(`${processedPages.length} pages processed`, 'success'); enableAllRotateButtons(true); setTimeout(()=>showStatus('', null), 900); }, 400);
}

/* ========= UI update for a processed page ========= */
function renderProcessedPreview(index) {
  const p = processedPages[index];
  const preview = document.getElementById(`preview-${index}`);
  const rotEl = document.getElementById(`rotation-${index}`);
  const modelEl = document.getElementById(`model-${index}`);
  if (!preview || !rotEl) return;
  if (p && p.canvas) preview.src = p.canvas.toDataURL('image/jpeg', 0.88);
  rotEl.textContent = p.rotation === 0 ? 'No rotation' : (p.rotation + '¬∞');
  modelEl.innerHTML = p.choseBy === 'knn' ? '<span class="learned-badge">Model</span>' : '<span class="meta">heuristic</span>';
}

/* ========= Rotate controls ========= */
function enableAllRotateButtons(enable) {
  pagesGrid.querySelectorAll('button[data-action]').forEach(b => {
    const action = b.getAttribute('data-action');
    if (action === 'del') { b.disabled = false; return; }
    b.disabled = !enable;
  });
}

function manualRotate(index, delta) {
  const page = processedPages[index];
  if (!page) return;
  const newRot = (((page.rotation || 0) + delta) % 360 + 360) % 360;
  const newCanvas = rotateCanvas(page.canvas, delta);
  processedPages[index].canvas = newCanvas;
  processedPages[index].rotation = newRot;
  // Save training example using original features (if available)
  if (page.features && autoLearnToggle.checked) {
    saveTrainingExample(page.features, newRot);
  }
  renderProcessedPreview(index);
}

function resetPageRotation(index) {
  const p = processedPages[index];
  if (!p) return;
  detectAndCorrectOrientation(p.originalDataUrl).then(result => {
    result.originalDataUrl = p.originalDataUrl;
    processedPages[index] = result;
    renderProcessedPreview(index);
  }).catch(err => { console.error(err); showStatus('Reset failed', 'error'); setTimeout(()=>showStatus('', null), 900); });
}

function deletePage(index) {
  uploadedImages.splice(index, 1);
  processedPages.splice(index, 1);
  renderPagesGrid();
  // re-render previews for processedPages that remain
  for (let i=0;i<processedPages.length;i++) {
    const pr = document.getElementById(`preview-${i}`);
    if (pr && processedPages[i] && processedPages[i].canvas) pr.src = processedPages[i].canvas.toDataURL('image/jpeg', 0.88);
    const rot = document.getElementById(`rotation-${i}`);
    if (rot && processedPages[i]) rot.textContent = processedPages[i].rotation + '¬∞';
  }
}

/* ========= PDF generation ========= */
function generatePDF() {
  //if (!processedPages || processedPages.length === 0) return showStatus('No pages to export', 'error');
  showStatus('Generating PDF...', 'processing');
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF();
  for (let i=0;i<processedPages.length;i++) {
    const page = processedPages[i];
    if (!page || !page.canvas) continue;
    if (i > 0) pdf.addPage();
    const canvas = page.canvas;
    const img = canvas.toDataURL('image/jpeg', 0.9);
    const pdfW = pdf.internal.pageSize.getWidth();
    const pdfH = pdf.internal.pageSize.getHeight();
    const imgRatio = canvas.height / canvas.width;
    let imgW = pdfW - 20; let imgH = imgW * imgRatio;
    if (imgH > pdfH - 20) { imgH = pdfH - 20; imgW = imgH / imgRatio; }
    const x = (pdfW - imgW) / 2, y = (pdfH - imgH) / 2;
    pdf.addImage(img, 'JPEG', x, y, imgW, imgH);
  
  pdf.save('scanned-document.pdf');
  showStatus('PDF downloaded', 'success');
  setTimeout(()=> showStatus('', null), 900);
}

/* ========= Clear ========= */
function clearAll() {
  if (!confirm('Clear all images and processed pages?')) return;
  uploadedImages = []; processedPages = []; pagesGrid.innerHTML = ''; imageInput.value = '';
  processBtn.disabled = true;showStatus('All cleared', 'success');
  setTimeout(()=> showStatus('', null), 900);
}

/* initial render */
renderPagesGrid();
updateModelInfo();
</script>
</body>
</html>