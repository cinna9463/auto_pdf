<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>PDF Export — robust test</title>

  <!-- PDF libraries (pdf-lib + jsPDF). Keep both so we have a fallback. -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    body { font-family: system-ui, Arial; padding: 16px; }
    .controls { margin-bottom: 12px; }
    .page { display:inline-block; margin:8px; text-align:center; }
    .page img { max-width:160px; border:1px solid #ddd; display:block; }
    button { padding:8px 12px; margin-right:8px; }
  </style>
</head>
<body>
  <h2>PDF export test (robust)</h2>

  <div class="controls">
    <input id="fileInput" type="file" accept="image/*" multiple />
    <button id="genBtn">Generate PDF</button>
    <label><input id="autoLearn" type="checkbox" checked /> Auto-learn (no-op in this test)</label>
  </div>

  <div id="pages" aria-live="polite"></div>

<script>
/* ---------- helper to render uploaded images ---------- */
const fileInput = document.getElementById('fileInput');
const pagesEl = document.getElementById('pages');
fileInput.addEventListener('change', async (e) => {
  pagesEl.innerHTML = '';
  for (const f of Array.from(e.target.files)) {
    const url = URL.createObjectURL(f);
    const div = document.createElement('div');
    div.className = 'page';
    // image element
    const img = document.createElement('img');
    img.src = url;
    img.alt = f.name;
    img.dataset.src = url; // original src
    img.style.transform = 'rotate(0deg)';
    // rotate controls
    const left = document.createElement('button'); left.textContent = '⟲'; left.onclick = () => rotate(img, -90);
    const right = document.createElement('button'); right.textContent = '⟳'; right.onclick = () => rotate(img, 90);
    // display rotation label
    const rotLabel = document.createElement('div'); rotLabel.className = 'rotlabel'; rotLabel.textContent = '0°';
    div.appendChild(img);
    div.appendChild(rotLabel);
    div.appendChild(left);
    div.appendChild(right);
    pagesEl.appendChild(div);
  }
});

function rotate(img, delta) {
  // read current rotation from style transform (rotate(Ndeg))
  const m = img.style.transform.match(/rotate\((-?\d+)deg\)/);
  const cur = m ? parseInt(m[1], 10) : 0;
  const next = ((cur + delta) % 360 + 360) % 360;
  img.style.transform = `rotate(${next}deg)`;
  const label = img.parentElement.querySelector('.rotlabel');
  if (label) label.textContent = `${next}°`;
}

/* ---------- robust generatePDF (uses pdf-lib if available, else jspdf) ---------- */

async function generatePDF() {
  // collect images: prefer processed array if your app exposes it; otherwise grab images from DOM
  let imageEls = [];

  // try common global names from various implementations:
  if (typeof processedPages !== 'undefined' && Array.isArray(processedPages) && processedPages.length) {
    // expecting processedPages items to contain either .canvas or .originalDataUrl/.rotation
    processedPages.forEach(p => {
      // if canvas is present create dataURL, else use originalDataUrl
      if (p && p.canvas) {
        imageEls.push({ srcType: 'dataurl', data: p.canvas.toDataURL('image/jpeg', 0.9), rotation: p.rotation || 0 });
      } else if (p && (p.originalDataUrl || p.url || p.dataUrl)) {
        imageEls.push({ srcType: 'url', data: p.originalDataUrl || p.url || p.dataUrl, rotation: p.rotation || 0 });
      }
    });
  }

  // If still empty, fall back to DOM images (common selectors)
  if (imageEls.length === 0) {
    const selectorCandidates = ['#pages img', '.page img', '.page-preview', '.page-item img', 'img'];
    // prefer images inside our pages container if present
    let imgNodes = [];
    if (document.querySelector('#pages')) {
      imgNodes = Array.from(document.querySelectorAll('#pages img'));
    }
    if (!imgNodes.length) {
      for (const sel of selectorCandidates) {
        imgNodes = Array.from(document.querySelectorAll(sel));
        if (imgNodes.length) break;
      }
    }
    // build entries: read src and rotation from style if present
    for (const img of imgNodes) {
      const src = img.dataset?.src || img.src;
      // parse rotation from style transform rotate(Xdeg)
      const m = (img.style && img.style.transform) ? img.style.transform.match(/rotate\((-?\d+)deg\)/) : null;
      const rotation = m ? (parseInt(m[1],10) % 360 + 360) % 360 : 0;
      imageEls.push({ srcType: 'url', data: src, rotation });
    }
  }

  if (imageEls.length === 0) {
    alert('No images found to export.');
    return;
  }

  // Helper: load image element (from url or dataurl)
  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      // to avoid cross-origin tainting issues, set crossOrigin if using external URLs (may still fail)
      img.crossOrigin = 'anonymous';
      img.src = src;
    });
  }

  // Helper: create rotated canvas for a given image and rotation degrees
  function canvasFromImageWithRotation(img, rotation) {
    const deg = ((rotation % 360) + 360) % 360;
    const rad = deg * Math.PI / 180;
    const w = img.naturalWidth, h = img.naturalHeight;
    const canvas = document.createElement('canvas');
    if (deg === 90 || deg === 270) {
      canvas.width = h; canvas.height = w;
    } else {
      canvas.width = w; canvas.height = h;
    }
    const ctx = canvas.getContext('2d');
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(rad);
    ctx.drawImage(img, -w/2, -h/2);
    return canvas;
  }

  // Build canvases (rotated) for each image, sequentially to avoid too many parallel loads
  const canvases = [];
  for (const entry of imageEls) {
    try {
      const src = entry.data;
      const img = await loadImage(src);
      const canvas = canvasFromImageWithRotation(img, entry.rotation || 0);
      canvases.push({ canvas, width: canvas.width, height: canvas.height });
    } catch (err) {
      console.warn('Failed to load image for PDF:', entry, err);
    }
  }

  if (canvases.length === 0) {
    alert('No images could be loaded for PDF.');
    return;
  }

  // Prefer pdf-lib if available
  if (typeof PDFLib !== 'undefined') {
    try {
      const pdfDoc = await PDFLib.PDFDocument.create();
      for (const c of canvases) {
        // convert canvas to JPEG arrayBuffer
        const dataUrl = c.canvas.toDataURL('image/jpeg', 0.9);
        const arrBuf = await (await fetch(dataUrl)).arrayBuffer();
        // embed image (try JPG first; pdf-lib is smart about format detection via embedJpg/embedPng)
        let embedded;
        try { embedded = await pdfDoc.embedJpg(arrBuf); } catch(e) {
          // fallback to PNG
          embedded = await pdfDoc.embedPng(arrBuf);
        }
        const page = pdfDoc.addPage([embedded.width, embedded.height]);
        page.drawImage(embedded, { x: 0, y: 0, width: embedded.width, height: embedded.height });
      }
      const pdfBytes = await pdfDoc.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'document.pdf'; a.click();
      URL.revokeObjectURL(url);
      return;
    } catch (err) {
      console.warn('pdf-lib export failed, falling back to jsPDF:', err);
      // fallthrough to jsPDF fallback
    }
  }

  // Fallback: use jsPDF (window.jspdf)
  if (window.jspdf && window.jspdf.jsPDF) {
    try {
      const { jsPDF } = window.jspdf;
      let doc = null;
      for (let i = 0; i < canvases.length; i++) {
        const c = canvases[i];
        const dataUrl = c.canvas.toDataURL('image/jpeg', 0.9);
        const w = c.width, h = c.height;
        if (i === 0) {
          doc = new jsPDF({ unit: 'px', format: [w, h] });
        } else {
          doc.addPage([w, h]);
        }
        doc.addImage(dataUrl, 'JPEG', 0, 0, w, h);
      }
      doc.save('document.pdf');
      return;
    } catch (err) {
      console.error('jsPDF fallback also failed:', err);
      alert('PDF generation failed (both pdf-lib and jsPDF). See console for details.');
      return;
    }
  }

  // If we reach here, no supported library available
  alert('No PDF library available (pdf-lib or jsPDF). Make sure you included the CDN script tags.');
}

/* hook button */
document.getElementById('genBtn').addEventListener('click', generatePDF);
</script>
</body>
</html>
