<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Auto Orient PDF Builder</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    .page { display: inline-block; margin: 10px; vertical-align: top; }
    .page img { max-width: 200px; display: block; margin-bottom: 5px; border: 1px solid #ccc; }
    .controls button { margin-right: 5px; }
  </style>
</head>
<body>
  <h2>Auto Orient PDF Builder</h2>
  <input type="file" id="fileInput" multiple accept="image/*" />
  <button onclick="downloadPDF()">Download PDF</button>
  <button onclick="exportLRModel()">Export Model</button>
  <input type="file" id="importModel" accept="application/json" onchange="handleImportModel(event)" />
  <label><input type="checkbox" id="autoLearn" checked /> Auto-learn on Export</label>
  <span id="modelStatus"></span>
  <div id="pages"></div>

<script>
/* ================= Logistic Regression Model ================= */

const LR_KEY = 'orientation_lr_v1';
const LR_CLASSES = [0,90,180,270];
const LR_DIM = 6;
let LR_LR = 0.25;
const LR_REG = 1e-4;
const LR_EPOCHS = 3;

function initLRModel() {
  const raw = localStorage.getItem(LR_KEY);
  if (raw) { try { const obj=JSON.parse(raw); if (obj && obj.W) return obj; } catch(e){} }
  const W = [];
  for (let c=0;c<LR_CLASSES.length;c++) {
    const row = new Array(LR_DIM+1).fill(0);
    for (let j=0;j<LR_DIM;j++) row[j]=(Math.random()-0.5)*0.02;
    W.push(row);
  }
  const model={W,learned:0,created:Date.now()};
  localStorage.setItem(LR_KEY, JSON.stringify(model));
  return model;
}
function loadLRModel(){ try{const raw=localStorage.getItem(LR_KEY); if(!raw)return initLRModel(); return JSON.parse(raw);}catch(e){return initLRModel();}}
function saveLRModel(m){ localStorage.setItem(LR_KEY, JSON.stringify(m)); }

function softmax(logits){const max=Math.max(...logits);const exps=logits.map(v=>Math.exp(v-max));const sum=exps.reduce((s,x)=>s+x,0);return exps.map(e=>e/sum);}

function predictLR(features){
  const model=loadLRModel(); const W=model.W;
  const logits=W.map(row=>{let s=0;for(let j=0;j<LR_DIM;j++)s+=row[j]*(features[j]||0);s+=row[LR_DIM];return s;});
  const probs=softmax(logits);
  let best=0; for(let i=1;i<probs.length;i++)if(probs[i]>probs[best])best=i;
  return {rotation:LR_CLASSES[best],probs,confidence:probs[best]};
}

function trainLR(features,rotationLabel){
  const model=loadLRModel(); const W=model.W; const classIdx=LR_CLASSES.indexOf(rotationLabel); if(classIdx<0)return;
  for(let e=0;e<LR_EPOCHS;e++){
    const logits=W.map(row=>{let s=0;for(let j=0;j<LR_DIM;j++)s+=row[j]*(features[j]||0);s+=row[LR_DIM];return s;});
    const probs=softmax(logits);
    for(let c=0;c<W.length;c++){const yc=(c===classIdx)?1:0;const err=probs[c]-yc;
      for(let j=0;j<LR_DIM;j++){W[c][j]-=LR_LR*(err*(features[j]||0)+LR_REG*W[c][j]);}
      W[c][LR_DIM]-=LR_LR*(err+LR_REG*W[c][LR_DIM]);
    }
  }
  model.learned=(model.learned||0)+1; model.updated=Date.now(); saveLRModel(model); updateModelStatus();
}

function exportLRModel(){
  const m=loadLRModel(); const blob=new Blob([JSON.stringify(m)],{type:'application/json'});
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='orientation_lr_model.json';a.click();URL.revokeObjectURL(a.href);
}
function handleImportModel(ev){const f=ev.target.files[0];if(!f)return;const fr=new FileReader();fr.onload=()=>{try{const p=JSON.parse(fr.result);if(p&&p.W)saveLRModel(p);updateModelStatus();}catch(e){alert('Import failed')}};fr.readAsText(f);}
function updateModelStatus(){const m=loadLRModel();let examples=m.learned||0;document.getElementById('modelStatus').textContent=` Model: weights=${m.W.length}, examples=${examples}`;}
initLRModel(); updateModelStatus();

/* ================= Page Handling ================= */

let pages=[];

document.getElementById('fileInput').addEventListener('change',e=>{
  for(const file of e.target.files){
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{
      // try to predict but fallback to 0° if something fails
      let rotation = 0;
      let features = [];
      try {
        features = extractFeatures(img);
        const pred = predictLR(features);
        rotation = pred.rotation || 0;
      } catch (err) {
        console.warn("Prediction skipped:", err);
      }
      addPage(url, rotation, features);
    };
    img.src=url;
  }
});

function addPage(url,rotation,features){
  const div=document.createElement('div');div.className='page';
  const img=document.createElement('img');img.src=url;img.style.transform=`rotate(${rotation}deg)`;
  const controls=document.createElement('div');controls.className='controls';
  const btnL=document.createElement('button');btnL.textContent='⟲';btnL.onclick=()=>rotatePage(div,-90);
  const btnR=document.createElement('button');btnR.textContent='⟳';btnR.onclick=()=>rotatePage(div,90);
  controls.appendChild(btnL);controls.appendChild(btnR);
  div.appendChild(img);div.appendChild(controls);
  document.getElementById('pages').appendChild(div);
  pages.push({div,img,rotation,features});
}
function rotatePage(div,delta){const p=pages.find(x=>x.div===div);p.rotation=(p.rotation+delta+360)%360;p.img.style.transform=`rotate(${p.rotation}deg)`;}

/* very simple "features" just for demo — real one can be better */
function extractFeatures(img){
  const canvas=document.createElement('canvas');canvas.width=img.naturalWidth;canvas.height=img.naturalHeight;
  const ctx=canvas.getContext('2d');ctx.drawImage(img,0,0);
  const data=ctx.getImageData(0,0,canvas.width,canvas.height).data;
  let sumX=0,sumY=0,sum=0;
  for(let i=0;i<data.length;i+=4){const v=(data[i]+data[i+1]+data[i+2])/3;const idx=i/4;const x=idx%canvas.width;const y=Math.floor(idx/canvas.width);sumX+=x*v;sumY+=y*v;sum+=v;}
  const cx=sumX/sum/canvas.width, cy=sumY/sum/canvas.height;
  return [cx,cy,sum/(canvas.width*canvas.height*255), img.naturalWidth/img.naturalHeight, Math.random(), Math.random()];
}

/* ================= PDF Export ================= */

async function downloadPDF(){
  if (pages.length === 0) {
    alert("No pages uploaded!");
    return;
  }
  const pdf=await PDFLib.PDFDocument.create();
  for(const p of pages){
    const jpg=await fetch(p.img.src).then(r=>r.arrayBuffer());
    const img=await pdf.embedJpg(jpg);
    const page=pdf.addPage([img.width,img.height]);
    // even if rotation undefined, fallback to 0
    const rot = p.rotation || 0;
    page.drawImage(img,{x:0,y:0,width:img.width,height:img.height,rotate:PDFLib.degrees(rot)});
    if(document.getElementById('autoLearn').checked){
      try { trainLR(p.features, rot); } catch {}
    }
  }
  const blob=await pdf.save();
  const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([blob]));a.download='output.pdf';a.click();URL.revokeObjectURL(a.href);
}
</script>
</body>
</html>
